<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, maximum-scale=1.0, user-scalable=no">
    <title>Ultimate Smooth Cube v2.0</title>
    <style>
        :root {
            --cube-size: min(260px, 60vw);
            --cubie-size: calc(var(--cube-size) / 3);
            --gap: 1px;
            --speed: 0.3s;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body { 
            background: radial-gradient(circle at center, #222, #000); 
            color: #fff; font-family: sans-serif; overflow: hidden; height: 100vh;
            display: flex; flex-direction: column;
        }

        /* 頂部 UI */
        .header {
            padding: env(safe-area-inset-top) 20px 10px;
            display: flex; justify-content: space-between; align-items: center;
            background: rgba(0,0,0,0.5); z-index: 10;
        }
        .moves { font-family: monospace; color: #FFD700; font-size: 1.2rem; }

        /* 3D 遊戲區 */
        .scene { 
            flex: 1; width: 100%; perspective: 1200px; 
            display: flex; justify-content: center; align-items: center; 
            touch-action: none; 
        }
        .cube-wrapper { 
            width: var(--cube-size); height: var(--cube-size); 
            transform-style: preserve-3d; 
            transform: rotateX(-30deg) rotateY(-45deg);
        }

        /* 方塊實體 */
        .cubie { 
            position: absolute; width: var(--cubie-size); height: var(--cubie-size); 
            transform-style: preserve-3d; 
            transition: transform var(--speed) cubic-bezier(0.25, 1, 0.5, 1);
        }
        .face { 
            position: absolute; width: 100%; height: 100%; 
            border: calc(var(--cubie-size) * 0.08) solid #000; 
            border-radius: 12%; backface-visibility: hidden; 
        }

        /* 國際標準配色 */
        .f-F { background: #d50000; transform: rotateY(0deg)   translateZ(calc(var(--cubie-size)/2)); }
        .f-B { background: #ff6d00; transform: rotateY(180deg) translateZ(calc(var(--cubie-size)/2)); }
        .f-U { background: #0091ea; transform: rotateX(90deg)  translateZ(calc(var(--cubie-size)/2)); }
        .f-D { background: #00c853; transform: rotateX(-90deg) translateZ(calc(var(--cubie-size)/2)); }
        .f-L { background: #ffffff; transform: rotateY(-90deg) translateZ(calc(var(--cubie-size)/2)); }
        .f-R { background: #ffd600; transform: rotateY(90deg)  translateZ(calc(var(--cubie-size)/2)); }

        /* 底部按鈕 */
        .footer {
            padding: 10px 10px calc(env(safe-area-inset-bottom) + 20px);
            display: flex; gap: 15px; justify-content: center; z-index: 10;
        }
        button {
            padding: 12px 25px; border: none; border-radius: 50px;
            background: #FFD700; color: #000; font-weight: bold;
            box-shadow: 0 4px 15px rgba(255,215,0,0.3); cursor: pointer;
        }
        button:active { transform: scale(0.9); }
        .hint { position: absolute; bottom: 85px; font-size: 12px; opacity: 0.5; width: 100%; text-align: center; }
    </style>
</head>
<body>

<div class="header">
    <div class="moves">MOVES: <span id="mCount">0</span></div>
    <h2 style="font-size: 1rem; color: #888;">Ultimate Cube</h2>
</div>

<div class="scene" id="scene">
    <div class="cube-wrapper" id="cube"></div>
</div>

<div class="hint">撥動方塊轉動層，撥動背景轉視角</div>

<div class="footer">
    <button onclick="cube.scramble()">打亂魔方</button>
    <button onclick="cube.reset()" style="background: #444; color: #fff;">重置</button>
</div>

<script>
/**
 * 核心邏輯：空間座標矩陣變換
 */
class UltimateCube {
    constructor() {
        this.wrapper = document.getElementById('cube');
        this.mDisplay = document.getElementById('mCount');
        this.cubies = [];
        this.isAnimating = false;
        this.moves = 0;
        
        this.viewX = -30;
        this.viewY = -45;

        this.init();
        this.bindEvents();
    }

    init() {
        this.wrapper.innerHTML = '';
        this.cubies = [];
        this.moves = 0;
        this.mDisplay.innerText = "0";

        for (let x = -1; x <= 1; x++) {
            for (let y = -1; y <= 1; y++) {
                for (let z = -1; z <= 1; z++) {
                    const el = document.createElement('div');
                    el.className = 'cubie';
                    ['F','B','U','D','L','R'].forEach(f => {
                        const face = document.createElement('div');
                        face.className = `face f-${f}`;
                        el.appendChild(face);
                    });
                    const obj = { el, x, y, z, matrix: new DOMMatrix() };
                    this.updatePos(obj);
                    this.wrapper.appendChild(el);
                    this.cubies.push(obj);
                }
            }
        }
    }

    updatePos(c) {
        const s = (document.body.clientWidth < 500) ? (window.innerWidth * 0.6 / 3) : 87;
        c.el.style.transform = `translate3d(${c.x*s}px, ${c.y*s}px, ${c.z*s}px) ${c.matrix.toString()}`;
    }

    rotateLayer(axis, layer, clockwise) {
        if (this.isAnimating) return;
        this.isAnimating = true;
        
        const angle = clockwise ? 90 : -90;
        const rad = (angle * Math.PI) / 180;
        const cos = Math.round(Math.cos(rad));
        const sin = Math.round(Math.sin(rad));

        const targets = this.cubies.filter(c => Math.round(c[axis]) === layer);

        targets.forEach(c => {
            // 1. 矩陣物理旋轉
            const m = new DOMMatrix();
            if (axis === 'x') m.rotateSelf(angle, 0, 0);
            if (axis === 'y') m.rotateSelf(0, -angle, 0);
            if (axis === 'z') m.rotateSelf(0, 0, angle);
            c.matrix = m.multiply(c.matrix);

            // 2. 邏輯座標變換
            const {x, y, z} = c;
            if (axis === 'x') {
                c.y = y * cos - z * sin;
                c.z = y * sin + z * cos;
            } else if (axis === 'y') {
                c.x = x * cos + z * sin;
                c.z = -x * sin + z * cos;
            } else if (axis === 'z') {
                c.x = x * cos - y * sin;
                c.y = x * sin + y * cos;
            }
            this.updatePos(c);
        });

        this.moves++;
        this.mDisplay.innerText = this.moves;
        setTimeout(() => { this.isAnimating = false; }, 320);
    }

    bindEvents() {
        let isView = false, isCube = false;
        let sx, sy, targetObj;

        const start = (e) => {
            const p = e.touches ? e.touches[0] : e;
            sx = p.pageX; sy = p.pageY;
            if (e.target.classList.contains('face')) {
                isCube = true;
                targetObj = this.cubies.find(c => c.el === e.target.parentElement);
            } else {
                isView = true;
            }
        };

        const move = (e) => {
            if (!isView) return;
            const p = e.touches ? e.touches[0] : e;
            this.viewY += (p.pageX - sx) * 0.5;
            this.viewX -= (p.pageY - sy) * 0.5;
            this.wrapper.style.transform = `rotateX(${this.viewX}deg) rotateY(${this.viewY}deg)`;
            sx = p.pageX; sy = p.pageY;
        };

        const end = (e) => {
            if (isCube && targetObj) {
                const p = e.changedTouches ? e.changedTouches[0] : e;
                const dx = p.pageX - sx, dy = p.pageY - sy;
                if (Math.abs(dx) > 20 || Math.abs(dy) > 20) {
                    if (Math.abs(dx) > Math.abs(dy)) {
                        this.rotateLayer('y', targetObj.y, dx > 0);
                    } else {
                        // 根據點擊位置決定轉 X 還是 Z
                        if (Math.abs(targetObj.x) >= Math.abs(targetObj.z)) {
                            this.rotateLayer('x', targetObj.x, dy > 0);
                        } else {
                            this.rotateLayer('z', targetObj.z, dy > 0);
                        }
                    }
                }
            }
            isView = isCube = false;
        };

        const s = document.getElementById('scene');
        s.addEventListener('touchstart', start, {passive: false});
        window.addEventListener('touchmove', move, {passive: false});
        window.addEventListener('touchend', end);
        s.addEventListener('mousedown', start);
        window.addEventListener('mousemove', move);
        window.addEventListener('mouseup', end);
    }

    scramble() {
        let count = 0;
        const axes = ['x','y','z'];
        const timer = setInterval(() => {
            this.rotateLayer(axes[Math.floor(Math.random()*3)], Math.floor(Math.random()*3)-1, Math.random()>0.5);
            if (++count > 15) {
                clearInterval(timer);
                this.moves = 0; this.mDisplay.innerText = "0";
            }
        }, 350);
    }

    reset() { this.init(); this.wrapper.style.transform = `rotateX(-30deg) rotateY(-45deg)`; }
}

const cube = new UltimateCube();
</script>
</body>
</html>
