<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, maximum-scale=1.0, user-scalable=no">
    <title>Mobile Smooth Cube</title>
    <style>
        :root {
            /* 根據螢幕大小自動調整魔方尺寸 */
            --cube-size: min(220px, 50vw);
            --cubie-size: calc(var(--cube-size) / 3);
            --offset: calc(var(--cubie-size) + 1px);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body { 
            background: #111; 
            color: white; 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            overflow: hidden; /* 防止整個網頁晃動 */
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* 頂部控制區，確保在手機上絕對看得到 */
        .top-bar {
            padding-top: env(safe-area-inset-top);
            background: rgba(40, 40, 40, 0.8);
            padding: 15px;
            display: flex;
            justify-content: space-around;
            align-items: center;
            z-index: 100;
        }

        .stats { color: #FFD700; font-family: monospace; font-weight: bold; }

        /* 中間遊戲區 */
        .scene { 
            flex: 1; 
            width: 100%; 
            perspective: 1000px; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            touch-action: none; /* 禁用預設手勢 */
        }

        .cube-wrapper { 
            width: var(--cube-size); 
            height: var(--cube-size); 
            transform-style: preserve-3d; 
            transform: rotateX(-30deg) rotateY(-45deg); 
            transition: transform 0.1s linear;
        }

        .cubie { 
            position: absolute; 
            width: var(--cubie-size); 
            height: var(--cubie-size); 
            transform-style: preserve-3d; 
            transition: transform 0.3s cubic-bezier(0.18, 0.89, 0.32, 1.28); 
        }

        .face { 
            position: absolute; 
            width: 100%; 
            height: 100%; 
            border: 2px solid black; 
            border-radius: 4px; 
            backface-visibility: hidden; 
        }
        
        /* 半徑偏移量需動態計算 */
        .face-F { background: #df0000; transform: rotateY(0deg) translateZ(calc(var(--cubie-size)/2)); }
        .face-B { background: #ff8000; transform: rotateY(180deg) translateZ(calc(var(--cubie-size)/2)); }
        .face-U { background: #0045ad; transform: rotateX(90deg) translateZ(calc(var(--cubie-size)/2)); }
        .face-D { background: #009b48; transform: rotateX(-90deg) translateZ(calc(var(--cubie-size)/2)); }
        .face-L { background: #ffffff; transform: rotateY(-90deg) translateZ(calc(var(--cubie-size)/2)); }
        .face-R { background: #ffd500; transform: rotateY(90deg) translateZ(calc(var(--cubie-size)/2)); }

        /* 底部操作區 */
        .bottom-bar {
            padding-bottom: env(safe-area-inset-bottom);
            padding: 20px;
            display: flex;
            gap: 10px;
            justify-content: center;
            background: linear-gradient(transparent, rgba(0,0,0,0.8));
        }

        button { 
            padding: 12px 20px; 
            border-radius: 25px; 
            border: none; 
            background: #FFD700; 
            color: black; 
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }

        button:active { transform: scale(0.95); opacity: 0.8; }
    </style>
</head>
<body>

<div class="top-bar">
    <div class="stats">MOVES: <span id="count">0</span></div>
    <button onclick="cube.scramble()">隨機打亂</button>
    <button onclick="cube.reset()">重置</button>
</div>

<div class="scene" id="scene">
    <div class="cube-wrapper" id="cube"></div>
</div>

<div class="bottom-bar">
    <p style="font-size: 12px; opacity: 0.6;">滑動背景轉視角 / 滑動魔方轉層</p>
</div>

<script>
class MobileCube {
    constructor() {
        this.wrapper = document.getElementById('cube');
        this.cubies = [];
        this.isAnimating = false;
        this.moves = 0;
        this.viewX = -30;
        this.viewY = -45;
        this.init();
        this.setupInteractions();
    }

    init() {
        this.wrapper.innerHTML = '';
        this.cubies = [];
        this.moves = 0;
        document.getElementById('count').innerText = "0";
        for (let x = -1; x <= 1; x++) {
            for (let y = -1; y <= 1; y++) {
                for (let z = -1; z <= 1; z++) {
                    const el = document.createElement('div');
                    el.className = 'cubie';
                    ['F','B','U','D','L','R'].forEach(f => {
                        const face = document.createElement('div');
                        face.className = `face face-${f}`;
                        el.appendChild(face);
                    });
                    const cubieObj = { el, x, y, z, matrix: new DOMMatrix() };
                    this.updateCSS(cubieObj);
                    this.wrapper.appendChild(el);
                    this.cubies.push(cubieObj);
                }
            }
        }
    }

    updateCSS(c) {
        // 使用 getComputedStyle 確保動態讀取 CSS 變數中的長度
        const size = document.body.clientWidth < 500 ? (window.innerWidth * 0.5 / 3) + 1 : 81;
        c.el.style.transform = `translate3d(${c.x*size}px, ${c.y*size}px, ${c.z*size}px) ${c.matrix.toString()}`;
    }

    rotateLayer(axis, layer, clockwise) {
        if (this.isAnimating) return;
        this.isAnimating = true;
        const angle = clockwise ? 90 : -90;
        const rotating = this.cubies.filter(c => Math.round(c[axis]) === layer);

        rotating.forEach(c => {
            const m = new DOMMatrix();
            if (axis === 'x') m.rotateSelf(angle, 0, 0);
            if (axis === 'y') m.rotateSelf(0, -angle, 0);
            if (axis === 'z') m.rotateSelf(0, 0, angle);
            c.matrix = m.multiply(c.matrix);

            const ox = c.x, oy = c.y, oz = c.z;
            if (axis === 'z') {
                c.x = Math.round(ox * Math.cos(angle*Math.PI/180) - oy * Math.sin(angle*Math.PI/180));
                c.y = Math.round(ox * Math.sin(angle*Math.PI/180) + oy * Math.cos(angle*Math.PI/180));
            } else if (axis === 'x') {
                c.y = Math.round(oy * Math.cos(angle*Math.PI/180) - oz * Math.sin(angle*Math.PI/180));
                c.z = Math.round(oy * Math.sin(angle*Math.PI/180) + oz * Math.cos(angle*Math.PI/180));
            } else if (axis === 'y') {
                c.x = Math.round(ox * Math.cos(angle*Math.PI/180) + oz * Math.sin(angle*Math.PI/180));
                c.z = Math.round(-ox * Math.sin(angle*Math.PI/180) + oz * Math.cos(angle*Math.PI/180));
            }
            this.updateCSS(c);
        });
        this.moves++;
        document.getElementById('count').innerText = this.moves;
        setTimeout(() => this.isAnimating = false, 300);
    }

    handleSwipe(cubie, dx, dy) {
        const adx = Math.abs(dx), ady = Math.abs(dy);
        if (adx > ady) {
            this.rotateLayer('y', cubie.y, dx > 0);
        } else {
            // 手機端簡單邏輯：點擊位置靠近左右轉 X，中間轉 Z
            if (Math.abs(cubie.x) > 0) {
                this.rotateLayer('x', cubie.x, dy > 0);
            } else {
                this.rotateLayer('z', cubie.z, dy > 0);
            }
        }
    }

    setupInteractions() {
        let isDragView = false, isDragCube = false;
        let sx, sy, target;

        const start = (e) => {
            const p = e.touches ? e.touches[0] : e;
            sx = p.pageX; sy = p.pageY;
            if (e.target.classList.contains('face')) {
                isDragCube = true;
                target = this.cubies.find(c => c.el === e.target.parentElement);
            } else {
                isDragView = true;
            }
        };

        const move = (e) => {
            if (!isDragView) return;
            const p = e.touches ? e.touches[0] : e;
            this.viewY += (p.pageX - sx) * 0.7;
            this.viewX -= (p.pageY - sy) * 0.7;
            this.wrapper.style.transform = `rotateX(${this.viewX}deg) rotateY(${this.viewY}deg)`;
            sx = p.pageX; sy = p.pageY;
        };

        const end = (e) => {
            if (isDragCube && target) {
                const p = e.changedTouches ? e.changedTouches[0] : e;
                this.handleSwipe(target, p.pageX - sx, p.pageY - sy);
            }
            isDragView = isDragCube = false;
        };

        const s = document.getElementById('scene');
        s.addEventListener('touchstart', start, {passive: false});
        window.addEventListener('touchmove', move, {passive: false});
        window.addEventListener('touchend', end);
        s.addEventListener('mousedown', start);
        window.addEventListener('mousemove', move);
        window.addEventListener('mouseup', end);
    }

    scramble() {
        let c = 0;
        const t = setInterval(() => {
            this.rotateLayer(['x','y','z'][Math.floor(Math.random()*3)], [-1,0,1][Math.floor(Math.random()*3)], Math.random()>0.5);
            if (++c > 15) {
                clearInterval(t);
                this.moves = 0; document.getElementById('count').innerText = "0";
            }
        }, 320);
    }

    reset() { this.init(); this.wrapper.style.transform = `rotateX(-30deg) rotateY(-45deg)`; }
}

const cube = new MobileCube();
</script>
</body>
</html>
