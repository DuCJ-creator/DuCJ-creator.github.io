<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Playable Smooth Cube</title>
    <style>
        :root {
            --cube-size: 240px;
            --cubie-size: 78px;
            --transition-speed: 0.3s;
        }
        body { background: #111; color: white; font-family: sans-serif; overflow: hidden; height: 100vh; display: flex; flex-direction: column; align-items: center; }
        .header { padding: 15px; text-align: center; }
        .scene { flex: 1; width: 100%; perspective: 1200px; display: flex; justify-content: center; align-items: center; touch-action: none; }
        .cube-wrapper { width: var(--cube-size); height: var(--cube-size); transform-style: preserve-3d; transform: rotateX(-30deg) rotateY(-45deg); }
        .cubie { position: absolute; width: var(--cubie-size); height: var(--cubie-size); transform-style: preserve-3d; transition: transform var(--transition-speed) ease-out; }
        .face { position: absolute; width: 100%; height: 100%; border: 3px solid black; border-radius: 6px; backface-visibility: hidden; cursor: pointer; }
        
        /* 配色 */
        .face-F { background: #df0000; transform: rotateY(0deg) translateZ(39px); }
        .face-B { background: #ff8000; transform: rotateY(180deg) translateZ(39px); }
        .face-U { background: #0045ad; transform: rotateX(90deg) translateZ(39px); }
        .face-D { background: #009b48; transform: rotateX(-90deg) translateZ(39px); }
        .face-L { background: #ffffff; transform: rotateY(-90deg) translateZ(39px); }
        .face-R { background: #ffd500; transform: rotateY(90deg) translateZ(39px); }

        .controls { padding: 20px; display: flex; gap: 10px; }
        button { padding: 10px 20px; border-radius: 5px; border: none; background: #444; color: white; cursor: pointer; }
        .hint { font-size: 12px; color: #888; margin-top: 10px; }
    </style>
</head>
<body>

<div class="header">
    <h3>滑動方塊即可轉動！</h3>
    <div class="hint">點擊背景旋轉視角 | 點擊方塊轉動魔方</div>
</div>

<div class="scene" id="scene">
    <div class="cube-wrapper" id="cube"></div>
</div>

<div class="controls">
    <button onclick="cube.scramble()">隨機打亂</button>
    <button onclick="cube.reset()">重置</button>
</div>

<script>
class PlayableCube {
    constructor() {
        this.wrapper = document.getElementById('cube');
        this.cubies = [];
        this.isAnimating = false;
        this.viewX = -30;
        this.viewY = -45;
        this.init();
        this.setupInteractions();
    }

    init() {
        this.wrapper.innerHTML = '';
        this.cubies = [];
        for (let x = -1; x <= 1; x++) {
            for (let y = -1; y <= 1; y++) {
                for (let z = -1; z <= 1; z++) {
                    const el = document.createElement('div');
                    el.className = 'cubie';
                    ['F','B','U','D','L','R'].forEach(f => {
                        const face = document.createElement('div');
                        face.className = `face face-${f}`;
                        el.appendChild(face);
                    });
                    const cubieObj = { el, x, y, z, matrix: new DOMMatrix() };
                    this.updateCSS(cubieObj);
                    this.wrapper.appendChild(el);
                    this.cubies.push(cubieObj);
                }
            }
        }
    }

    updateCSS(c) {
        const offset = 81;
        c.el.style.transform = `translate3d(${c.x*offset}px, ${c.y*offset}px, ${c.z*offset}px) ${c.matrix.toString()}`;
    }

    rotateLayer(axis, layer, clockwise) {
        if (this.isAnimating) return;
        this.isAnimating = true;
        const angle = clockwise ? 90 : -90;
        const rotating = this.cubies.filter(c => Math.round(c[axis]) === layer);

        rotating.forEach(c => {
            const m = new DOMMatrix();
            if (axis === 'x') m.rotateSelf(angle, 0, 0);
            if (axis === 'y') m.rotateSelf(0, -angle, 0);
            if (axis === 'z') m.rotateSelf(0, 0, angle);
            c.matrix = m.multiply(c.matrix);

            const ox = c.x, oy = c.y, oz = c.z;
            if (axis === 'z') {
                c.x = Math.round(ox * Math.cos(angle*Math.PI/180) - oy * Math.sin(angle*Math.PI/180));
                c.y = Math.round(ox * Math.sin(angle*Math.PI/180) + oy * Math.cos(angle*Math.PI/180));
            } else if (axis === 'x') {
                c.y = Math.round(oy * Math.cos(angle*Math.PI/180) - oz * Math.sin(angle*Math.PI/180));
                c.z = Math.round(oy * Math.sin(angle*Math.PI/180) + oz * Math.cos(angle*Math.PI/180));
            } else if (axis === 'y') {
                c.x = Math.round(ox * Math.cos(angle*Math.PI/180) + oz * Math.sin(angle*Math.PI/180));
                c.z = Math.round(-ox * Math.sin(angle*Math.PI/180) + oz * Math.cos(angle*Math.PI/180));
            }
            this.updateCSS(c);
        });
        setTimeout(() => this.isAnimating = false, 310);
    }

    handleSwipe(cubie, dx, dy) {
        const adx = Math.abs(dx), ady = Math.abs(dy);
        if (adx > ady) {
            // 橫向滑動 -> 轉動 Y 軸層 (U, E, D)
            this.rotateLayer('y', cubie.y, dx > 0);
        } else {
            // 縱向滑動 -> 根據位置轉動 X 或 Z 軸層
            // 這裡做一個簡單判定：點擊側邊轉 X，點擊正面轉 Z
            if (Math.abs(this.viewY % 180) < 45) {
                this.rotateLayer('x', cubie.x, dy > 0);
            } else {
                this.rotateLayer('z', cubie.z, dy > 0);
            }
        }
    }

    setupInteractions() {
        let isDragView = false, isDragCube = false;
        let sx, sy, target;

        const start = (e) => {
            const p = e.touches ? e.touches[0] : e;
            sx = p.pageX; sy = p.pageY;
            if (e.target.classList.contains('face')) {
                isDragCube = true;
                target = this.cubies.find(c => c.el === e.target.parentElement);
            } else {
                isDragView = true;
            }
        };

        const move = (e) => {
            if (!isDragView) return;
            const p = e.touches ? e.touches[0] : e;
            this.viewY += (p.pageX - sx) * 0.5;
            this.viewX -= (p.pageY - sy) * 0.5;
            this.wrapper.style.transform = `rotateX(${this.viewX}deg) rotateY(${this.viewY}deg)`;
            sx = p.pageX; sy = p.pageY;
        };

        const end = (e) => {
            if (isDragCube && target) {
                const p = e.changedTouches ? e.changedTouches[0] : e;
                this.handleSwipe(target, p.pageX - sx, p.pageY - sy);
            }
            isDragView = isDragCube = false;
        };

        const s = document.getElementById('scene');
        s.addEventListener('mousedown', start);
        window.addEventListener('mousemove', move);
        window.addEventListener('mouseup', end);
        s.addEventListener('touchstart', start);
        window.addEventListener('touchmove', move);
        window.addEventListener('touchend', end);
    }

    scramble() {
        let c = 0;
        const t = setInterval(() => {
            this.rotateLayer(['x','y','z'][Math.floor(Math.random()*3)], [-1,0,1][Math.floor(Math.random()*3)], Math.random()>0.5);
            if (++c > 10) clearInterval(t);
        }, 350);
    }

    reset() { this.init(); this.wrapper.style.transform = `rotateX(-30deg) rotateY(-45deg)`; }
}

const cube = new PlayableCube();
</script>
</body>
</html>
