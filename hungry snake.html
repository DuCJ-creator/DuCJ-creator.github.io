<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Air 貪食蛇單字挑戰</title>
    <style>
        /* CSS 樣式 */
        :root {
            --primary-color: #4a6a3b;
            --secondary-color: #c4d7b9;
            --background-color: #f7f3e8;
            --snake-color: #659c44;
            --food-color: #576a77; /* 所有食物的統一顏色 */
        }

        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: var(--background-color); 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            overflow: hidden;
        }

        #game-container {
            display: none; 
            width: 95vw; 
            max-width: 1000px;
            height: 95vh;
            max-height: 800px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            border-radius: 8px;
            overflow: hidden;
            background-color: #fcfcf4;
            display: flex;
            flex-direction: row; 
        }
        
        /* 針對小螢幕/手機的響應式調整 */
        @media (max-width: 768px) {
            #game-container {
                flex-direction: column; 
                width: 98vw;
                height: 98vh;
            }
            #sidebar {
                width: 100%;
                min-height: 150px; 
                padding: 10px;
                order: 2; 
                flex-direction: row;
                justify-content: space-around;
                align-items: flex-start;
            }
            #game-area {
                order: 1; 
                min-height: 50vh; 
            }
            .panel { margin-bottom: 5px; padding: 5px; }
            #controls { 
                display: none !important; 
            } 
        }

        #game-area {
            flex-grow: 1; 
            position: relative;
            background-color: #f4f0e7; 
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #game-canvas {
            display: block;
            width: 100%;
            height: 100%;
            max-width: calc(95vh - 100px); 
            max-height: calc(95vh - 100px);
            transition: filter 0.1s;
        }

        .invulnerable-effect {
            /* 無敵時 Canvas 閃爍效果 */
            filter: drop-shadow(0 0 5px yellow) brightness(1.2);
        }

        #sidebar {
            width: 250px;
            min-width: 200px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #e4e0d7;
            box-sizing: border-box;
        }

        .panel {
            width: 100%;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        #word-panel { background-color: var(--secondary-color); }
        #word-panel h2 { margin: 0 0 5px 0; font-size: 24px; color: var(--primary-color); font-weight: 700; }
        #score-panel { background-color: var(--secondary-color); }
        #score-panel p { margin: 5px 0; font-size: 16px; color: var(--primary-color); }
        #timer-panel { background-color: var(--secondary-color); display: flex; flex-direction: column; align-items: center; }
        #timer-display { font-size: 32px; font-weight: bold; color: var(--primary-color); margin-bottom: 10px; }
        
        /* 設置畫面 CSS */
        #setup-screen {
            display: flex; 
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 50px;
            background-color: var(--background-color);
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            text-align: center;
            width: 90vw; 
            max-width: 400px;
        }

        .setup-group { margin-bottom: 25px; width: 100%; }
        .setup-group label { font-size: 18px; font-weight: bold; margin-bottom: 8px; color: var(--primary-color); display: block; }
        .setup-group select { padding: 10px; border-radius: 6px; border: 1px solid var(--secondary-color); width: 100%; font-size: 16px; background-color: white; }
        #start-game-btn { padding: 12px 25px; margin-top: 20px; font-size: 20px; background-color: var(--primary-color); color: white; border: none; border-radius: 6px; cursor: pointer; transition: background-color 0.2s; }
        #start-game-btn:hover { background-color: #3b572f; }
        
        /* 控制按鈕 CSS */
        #controls {
            display: grid;
            grid-template-areas: ". up ." "left pause right" ". down .";
            gap: 10px;
            width: 150px;
            margin-top: auto; 
        }

        #controls button { padding: 15px; border: none; border-radius: 8px; background-color: #d1cbc0; cursor: pointer; font-size: 18px; transition: background-color 0.1s; }
        #controls button:hover { background-color: #c3bbb2; }
        #controls button:active { background-color: #b5ac9f; }

        #up { grid-area: up; }
        #down { grid-area: down; }
        #left { grid-area: left; }
        #right { grid-area: right; }
        #pause, #resume { grid-area: pause; font-weight: bold; background-color: #e6e3da; }
        
        #end-game-btn {
            width: 100%;
            padding: 15px;
            margin-top: 20px;
            border: none;
            border-radius: 8px;
            background-color: #ae8a8a;
            color: white;
            font-weight: bold;
            cursor: pointer;
            display: none; 
        }

    </style>
</head>
<body>

    <div id="setup-screen">
        <h1>Air 貪食蛇單字挑戰</h1>
        <p>請選擇 Level 和單元範圍，然後開始遊戲。</p>

        <div class="setup-group">
            <label for="level-select">選擇 Level:</label>
            <select id="level-select"></select>
        </div>

        <div class="setup-group">
            <label for="unit-select">選擇 單元範圍:</label>
            <select id="unit-select"></select>
        </div>
        
        <button id="start-game-btn">開始遊戲</button>
    </div>

    <div id="game-container">
        <div id="game-area">
            <canvas id="game-canvas"></canvas>
            <div id="status-message" style="position: absolute; color: red; font-size: 2em; font-weight: bold; text-shadow: 1px 1px 2px black; display: none;"></div>
        </div>

        <div id="sidebar">
            <div id="word-panel" class="panel">
                <h2 id="current-word"></h2>
                <p id="question-meaning">請選擇正確含義</p>
            </div>

            <div id="score-panel" class="panel">
                <p>Score: <span id="current-score">0</span></p>
                <p>Combo: <span id="current-combo">0</span></p>
                <p>High: <span id="high-score">0</span></p>
                <p>Length: <span id="snake-length">1</span></p>
            </div>

            <div id="timer-panel" class="panel">
                <div id="timer-display">00:00</div>
                <div class="time-buttons">
                    <button data-time="5m">5m</button>
                    <button data-time="10m" class="active">10m</button>
                    <button data-time="15m">15m</button>
                </div>
            </div>

            <div id="controls">
                <button id="up">↑</button>
                <button id="left">←</button>
                <button id="pause">Pause</button>
                <button id="resume" style="display: none;">Resume</button>
                <button id="right">→</button>
                <button id="down">↓</button>
            </div>
            
            <button id="end-game-btn">End Game</button>
            
        </div>
    </div>

    <script>
        // Web Audio API 上下文
        let audioCtx = null;
        try {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        } catch (e) {
            console.warn('Web Audio API 不受支持或初始化失敗。將禁用音效。', e);
        }

        /**
         * 內嵌音效生成器
         * @param {string} type - 'success', 'fail', 'gameover'
         */
        function generateSound(type) {
            if (!audioCtx) return;
            
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }

            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            gainNode.connect(audioCtx.destination);
            oscillator.connect(gainNode);

            const now = audioCtx.currentTime;

            switch (type) {
                case 'success':
                    oscillator.type = 'square';
                    oscillator.frequency.setValueAtTime(880, now);
                    gainNode.gain.setValueAtTime(0.5, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                    oscillator.stop(now + 0.15);
                    break;
                case 'fail':
                    oscillator.type = 'sawtooth';
                    oscillator.frequency.setValueAtTime(160, now);
                    gainNode.gain.setValueAtTime(0.5, now);
                    gainNode.gain.linearRampToValueAtTime(0.01, now + 0.3);
                    oscillator.stop(now + 0.3);
                    break;
                case 'gameover':
                    oscillator.type = 'triangle';
                    oscillator.frequency.setValueAtTime(300, now);
                    oscillator.frequency.exponentialRampToValueAtTime(100, now + 0.5);
                    gainNode.gain.setValueAtTime(0.5, now);
                    gainNode.gain.linearRampToValueAtTime(0.001, now + 1.0);
                    oscillator.stop(now + 1.0);
                    break;
                default:
                    return;
            }

            oscillator.start();
        }


        // ====== 全局變量和初始化 ======

        // Canvas 相關
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas ? canvas.getContext('2d') : null; 
        
        // 遊戲狀態
        const GRID = 20; 
        let snakeGrid = []; 
        let snakePos = []; 
        let foods = []; 
        let direction = 'right'; 
        let nextDirection = 'right'; 
        let gameStarted = false;
        let gamePaused = false;
        let currentScore = 0;
        let highScore = 0;
        let currentWordData = null; 
        let currentWordDatabase = []; 
        let combo = 0; 
        let invulnerable = false; 
        let targetLength = 1; // 追蹤蛇的目標長度

        
        // 設置選項 (50 Unit, 每 5 個 Unit 為一個範圍)
        const LEVELS = [1, 2, 3, 4, 5, 6];
        const UNIT_RANGES = [
            '1-5', '6-10', '11-15', '16-20', '21-25', '26-30', 
            '31-35', '36-40', '41-45', '46-50' 
        ];

        // 平滑移動相關
        const MOVE_DURATION = 150; 
        let lastTime = 0;
        let moveProgress = 0; 

        // 計時器相關
        let totalTimeSeconds = 600; 
        let remainingTime = totalTimeSeconds;
        let timerInterval = null;

        // UI 元素
        const scoreEl = document.getElementById('current-score');
        const comboEl = document.getElementById('current-combo');
        const highEl = document.getElementById('high-score');
        const lengthEl = document.getElementById('snake-length');
        const wordEl = document.getElementById('current-word');
        const meaningEl = document.getElementById('question-meaning');
        const timerDisplay = document.getElementById('timer-display');
        const timeButtons = document.querySelector('.time-buttons');
        const levelSelect = document.getElementById('level-select');
        const unitSelect = document.getElementById('unit-select');
        const setupScreen = document.getElementById('setup-screen');
        const gameContainer = document.getElementById('game-container');
        const statusMessageEl = document.getElementById('status-message');
        const pauseBtn = document.getElementById('pause');
        const resumeBtn = document.getElementById('resume');
        const endBtn = document.getElementById('end-game-btn');


        // ====== 輔助函數：數據載入與處理 (保持不變) ======
        function parseCSV(csv) { 
            const lines = csv.split('\n').filter(line => line.trim() !== '');
            if (lines.length < 2) return [];

            const headers = lines[0].split(',').map(h => h.trim()); 
            const data = [];

            const unitIndex = headers.findIndex(h => h.toLowerCase() === 'unit');
            const wordIndex = headers.findIndex(h => h.toLowerCase() === 'word');
            const posIndex = headers.findIndex(h => h.toLowerCase() === 'pos');
            const chineseIndex = headers.findIndex(h => h.toLowerCase() === 'chinese meaning');
            
            if (unitIndex === -1 || wordIndex === -1 || chineseIndex === -1) {
                console.error("CSV 格式錯誤：缺少關鍵欄位。");
                return [];
            }

            for (let i = 1; i < lines.length; i++) {
                const values = lines[i].split(',').map(v => v.trim()); 
                if (values.length >= headers.length) {
                    data.push({
                        unit: parseInt(values[unitIndex], 10), 
                        word: values[wordIndex],
                        pos: values[posIndex],
                        chinese: values[chineseIndex],
                    });
                }
            }
            return data;
        }

        async function fetchWordData(level) { 
            const filename = `level${level}.csv`;
            const url = `https://ducj-creator.github.io/iVocab-Self-Practice/${filename}`; 
            
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP 錯誤! 狀態: ${response.status}`);
                }
                const csvText = await response.text();
                return parseCSV(csvText);

            } catch (error) {
                console.error(`載入 Level ${level} 數據時發生錯誤:`, error);
                alert(`無法載入 Level ${level} 數據。請檢查網路連線或 CSV 檔案路徑/格式。`);
                return [];
            }
        }

        function getFoodMeanings(rawData, correctMeaning) { 
            const allMeanings = rawData
                .map(d => d.chinese.split(';').map(m => m.trim())) 
                .flat()
                .filter(m => m !== correctMeaning && m !== ''); 
            
            const uniqueMeanings = [...new Set(allMeanings)];
            uniqueMeanings.sort(() => Math.random() - 0.5);

            const wrongMeanings = uniqueMeanings.slice(0, 3);
            let finalMeanings = [correctMeaning, ...wrongMeanings];

            while (finalMeanings.length < 4) {
                finalMeanings.push('其他選項'); 
            }
            
            finalMeanings.sort(() => Math.random() - 0.5);
            return finalMeanings.slice(0, 4); 
        }

        function newQuestion() { 
            if (currentWordDatabase.length === 0) return null;

            const randomIndex = Math.floor(Math.random() * currentWordDatabase.length);
            const rawWord = currentWordDatabase[randomIndex];
            
            const correctMeaning = rawWord.chinese.split(';')[0].trim(); 
            const meanings = getFoodMeanings(currentWordDatabase, correctMeaning);

            currentWordData = {
                word: rawWord.word, 
                pos: rawWord.pos, 
                meaning: correctMeaning, 
                meanings: meanings 
            };
            
            wordEl.textContent = `${currentWordData.word} (${currentWordData.pos})`;
            
            return currentWordData;
        }


        // ====== 設置畫面控制函數 (保持不變) ======

        function loadLevelOptions() { 
            levelSelect.innerHTML = '<option value="" disabled selected>請選擇 Level</option>';
            LEVELS.forEach(level => {
                const option = document.createElement('option');
                option.value = level;
                option.textContent = `Level ${level}`;
                levelSelect.appendChild(option);
            });
        }

        function loadUnitOptions() { 
            unitSelect.innerHTML = '<option value="" disabled selected>請選擇 單元範圍</option>';
            UNIT_RANGES.forEach(range => {
                const option = document.createElement('option');
                option.value = range;
                option.textContent = `Unit ${range}`;
                unitSelect.appendChild(option);
            });
        }
        
        // ====== 遊戲核心邏輯 ======

        function updateUI() {
            scoreEl.textContent = currentScore;
            highEl.textContent = highScore;
            lengthEl.textContent = snakeGrid.length; 
            comboEl.textContent = combo; 
            localStorage.setItem('snakeHigh', highScore);
        }
        
        function showStatus(message, color = 'red') {
            statusMessageEl.textContent = message;
            statusMessageEl.style.color = color;
            statusMessageEl.style.display = 'block';
            setTimeout(() => {
                statusMessageEl.style.display = 'none';
            }, 1000);
        }

        /** 處理分數變更和無敵狀態 */
        function handleScoreAndCollision(isCorrect, isSelfWallCollision = false) {
            
            if (isSelfWallCollision) {
                if (invulnerable) return false; 

                // 碰撞懲罰
                generateSound('fail');
                
                combo = 0; 
                currentScore = Math.max(0, currentScore - 10);
                
                if (targetLength > 1) {
                    targetLength--; // 目標長度減少
                    showStatus("撞擊！-10 分，長度 -1", 'red');
                } else {
                    endGame(false); 
                    return false; 
                }
                
                // 碰撞後短暫無敵
                invulnerable = true;
                canvas.classList.add('invulnerable-effect');
                setTimeout(() => {
                    invulnerable = false;
                    canvas.classList.remove('invulnerable-effect');
                }, 500);
                
                updateUI();
                return false; 

            } else if (isCorrect) {
                // 正確邏輯
                generateSound('success');
                
                combo++; 
                const scoreIncrease = combo * 10;
                currentScore += scoreIncrease;
                showStatus(`正確！+${scoreIncrease} (${combo} 連擊)`, 'green');

                targetLength++; // 目標長度增加
                
                // 1秒無敵時間
                invulnerable = true;
                canvas.classList.add('invulnerable-effect');
                setTimeout(() => {
                    invulnerable = false;
                    canvas.classList.remove('invulnerable-effect');
                }, 1000);
                
                // 重生新題目和食物
                const q = newQuestion();
                if (q) genFoods();
                
                updateUI();
                return true;

            } else { 
                // 錯誤選項邏輯
                generateSound('fail');
                
                combo = 0; 
                currentScore = Math.max(0, currentScore - 10);
                
                if (targetLength > 1) {
                    targetLength--; // 目標長度減少
                    showStatus("錯誤！連擊中斷 -10 分，長度 -1", 'red');
                } else {
                    endGame(false);
                    return false; 
                }
                
                // 保持當前題目，重新生成選項
                if (currentWordData) genFoods(); 

                updateUI();
                return false; 
            }
        }


        function checkCollision(head) {
            // 邊界碰撞
            if (head.x < 0 || head.x >= GRID || head.y < 0 || head.y >= GRID) {
                return handleScoreAndCollision(false, true); 
            }

            // 身體碰撞 
            for (let i = 1; i < snakeGrid.length; i++) {
                if (head.x === snakeGrid[i].x && head.y === snakeGrid[i].y) {
                    return handleScoreAndCollision(false, true); 
                }
            }

            // 食物碰撞
            const foodIndex = foods.findIndex(f => f.x === head.x && f.y === head.y);
            if (foodIndex !== -1) {
                const eatenFood = foods[foodIndex];
                return handleScoreAndCollision(eatenFood.isCorrect, false);
            }

            return false; 
        }

        // 啟動遊戲時重設目標長度
        function startGame() {
            if (!ctx) return; 

            currentScore = 0;
            combo = 0;
            remainingTime = totalTimeSeconds;
            
            snakeGrid = [{ x: Math.floor(GRID / 2), y: Math.floor(GRID / 2) }];
            targetLength = 1; // 初始目標長度

            resizeCanvas();
            updateSnakeSmoothPos(); 

            direction = 'right';
            nextDirection = 'right';
            moveProgress = 0;
            
            const q = newQuestion();
            if (!q) {
                alert("單元內沒有單字，無法開始遊戲。");
                setupScreen.style.display = 'flex';
                gameContainer.style.display = 'none';
                return;
            }
            genFoods();
            
            timerDisplay.textContent = formatTime(remainingTime);
            updateUI();
            
            gameStarted = true;
            gamePaused = false;
            invulnerable = false; 
            
            pauseBtn.style.display = 'block';
            resumeBtn.style.display = 'none';
            endBtn.style.display = 'block';

            startTimer();
            draw(); 
            
            lastTime = performance.now(); // 確保 lastTime 在遊戲開始時立即設置
            requestAnimationFrame(gameLoop);
        }

        function draw() {
            if (!ctx || !canvas) return;

            ctx.clearRect(0, 0, canvas.width, canvas.height); 
            const sz = canvas.width / GRID;
            const currentTime = performance.now();

            // 1. 繪製食物 (跳動動畫, 所有食物顏色統一)
            foods.forEach(food => {
                ctx.fillStyle = 'var(--food-color)'; /* 統一顏色 */
                
                const x = (food.x + 0.5) * sz;
                // 使用 Math.sin 實現上下跳動效果
                let y = (food.y + 0.5) * sz + Math.sin(currentTime / 300) * (sz * 0.05); 
                
                const r = sz / 2 * 0.4; 
                
                ctx.beginPath();
                ctx.arc(x, y, r, 0, Math.PI * 2);
                ctx.fill();
                
                // 繪製文字 (含義/選項)
                ctx.fillStyle = '#111';
                ctx.font = `${sz * 0.3}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(food.meaning, x, y + sz * 0.4); 
            });

            // 2. 繪製蛇
            if (snakePos.length > 0) {
                // 蛇頭 (無敵時顯示黃色)
                ctx.fillStyle = invulnerable ? '#FFD700' : 'var(--snake-color)';
                const headPos = snakePos[0];
                const r = sz / 2 * 0.9; 

                ctx.beginPath();
                ctx.arc(headPos.x, headPos.y, r, 0, Math.PI * 2);
                ctx.fill();

                // 蛇身 
                ctx.fillStyle = '#8bc34a'; 
                for (let i = 1; i < snakePos.length; i++) {
                    const bodyPos = snakePos[i];
                    
                    ctx.beginPath();
                    ctx.arc(bodyPos.x, bodyPos.y, r * 0.9, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        function gameLoop(currentTime) {
            if (!gameStarted) {
                // 如果遊戲未啟動，只需設置 lastTime 並等待
                lastTime = currentTime; 
                requestAnimationFrame(gameLoop);
                return;
            }
            if (gamePaused) {
                lastTime = currentTime; // 暫停時更新 lastTime，防止恢復時deltaTime過大
                requestAnimationFrame(gameLoop);
                return;
            }

            // 確保 lastTime 有效，防止第一次調用時 deltaTime 巨大
            if (lastTime === 0) {
                lastTime = currentTime;
            }

            const deltaTime = currentTime - lastTime;
            moveProgress = Math.min(1, deltaTime / MOVE_DURATION);

            if (snakeGrid.length > 0) {
                const headGrid = snakeGrid[0];
                
                let targetX = headGrid.x;
                let targetY = headGrid.y;

                switch (direction) {
                    case 'up': targetY -= 1; break;
                    case 'down': targetY += 1; break;
                    case 'left': targetX -= 1; break;
                    case 'right': targetX += 1; break;
                }

                const sz = canvas.width / GRID;
                const tx = (targetX + 0.5) * sz;
                const ty = (targetY + 0.5) * sz;
                
                // 使用 snakePos[0] 作為插值的起點
                const currentX = snakePos[0] ? snakePos[0].x : (headGrid.x + 0.5) * sz;
                const currentY = snakePos[0] ? snakePos[0].y : (headGrid.y + 0.5) * sz;

                snakePos[0] = { 
                    x: lerp(currentX, tx, moveProgress), 
                    y: lerp(currentY, ty, moveProgress) 
                };
                
                draw();
            }

            if (moveProgress >= 1) {
                
                direction = nextDirection;

                const head = { ...snakeGrid[0] };
                switch (direction) {
                    case 'up': head.y -= 1; break;
                    case 'down': head.y += 1; break;
                    case 'left': head.x -= 1; break;
                    case 'right': head.x += 1; break;
                }

                // 檢查碰撞/吃到食物
                checkCollision(head);
                
                // 1. 將新頭部添加到網格
                snakeGrid.unshift(head); 
                
                // 2. 根據目標長度決定是否移除尾部
                while (snakeGrid.length > targetLength) {
                    snakeGrid.pop(); 
                }
                
                lastTime = currentTime;
                moveProgress = 0;
                
                updateSnakeSmoothPos(); 
            }

            requestAnimationFrame(gameLoop);
        }

        // ====== 其他函數保持不變 ======
        function lerp(start, end, progress) { return start + (end - start) * progress; }
        function updateSnakeSmoothPos() { 
             const sz = canvas.width / GRID;
             if (snakeGrid.length > 0) {
                 snakePos[0] = { x: (snakeGrid[0].x + 0.5) * sz, y: (snakeGrid[0].y + 0.5) * sz };
                 for (let i = 1; i < snakeGrid.length; i++) {
                     snakePos[i] = { x: (snakeGrid[i].x + 0.5) * sz, y: (snakeGrid[i].y + 0.5) * sz };
                 }
             } else {
                 snakePos = [];
             }
        }
        function formatTime(seconds) { 
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            return `${String(minutes).padStart(2, '0')}:${String(remainingSeconds).padStart(2, '0')}`;
        }
        function startTimer() { 
            clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                if (!gamePaused) {
                    remainingTime--;
                    timerDisplay.textContent = formatTime(remainingTime);
                    if (remainingTime <= 0) {
                        clearInterval(timerInterval);
                        endGame(true);
                    }
                }
            }, 1000);
        }
        function resizeCanvas() { 
            if (!canvas) return;
            const gameArea = document.getElementById('game-area');
            const size = Math.min(gameArea.clientWidth, gameArea.clientHeight); 
            const canvasSize = Math.floor(size / GRID) * GRID;
            canvas.width = canvasSize;
            canvas.height = canvasSize;
            
            if (gameStarted) {
                updateSnakeSmoothPos();
                draw(); 
            }
        }
        function genFoods() { 
            foods = [];
            const meanings = currentWordData.meanings;
            
            for (let i = 0; i < meanings.length; i++) {
                const pos = getRandomGridPosition();
                foods.push({
                    ...pos,
                    meaning: meanings[i],
                    isCorrect: meanings[i] === currentWordData.meaning
                });
            }
        }
        function getRandomGridPosition() { 
            let x, y;
            let occupied;
            do {
                x = Math.floor(Math.random() * GRID);
                y = Math.floor(Math.random() * GRID);
                
                occupied = snakeGrid.some(p => p.x === x && p.y === y) ||
                           foods.some(f => f.x === x && f.y === y);
            } while (occupied);
            return { x, y };
        }
        function endGame(timeOut = false) { 
            if (!gameStarted) return;
            gameStarted = false;
            clearInterval(timerInterval);
            cancelAnimationFrame(gameLoop);
            generateSound('gameover');
            
            highScore = Math.max(highScore, currentScore);
            updateUI();
            
            alert(`遊戲結束！\n最終得分: ${currentScore}\n最終蛇身: ${targetLength}`);
            
            canvas.classList.remove('invulnerable-effect');

            setupScreen.style.display = 'flex';
            gameContainer.style.display = 'none';
        }
        // ====== 事件監聽器 (保持不變) ======

        window.addEventListener('resize', resizeCanvas);

        document.getElementById('start-game-btn').addEventListener('click', async () => {
            const selectedLevel = parseInt(levelSelect.value, 10);
            const rangeStr = unitSelect.value;
            
            if (isNaN(selectedLevel) || !rangeStr) {
                alert("請先選擇 Level 和單元範圍！");
                return;
            }
            
            const [minUnit, maxUnit] = rangeStr.split('-').map(Number);
            
            const rawData = await fetchWordData(selectedLevel);
            
            currentWordDatabase = rawData.filter(d => d.unit >= minUnit && d.unit <= maxUnit);

            if (currentWordDatabase.length === 0) {
                alert(`所選的 Level: ${selectedLevel}, 單元範圍: ${rangeStr} 沒有單字。`);
                return;
            }
            
            setupScreen.style.display = 'none';
            gameContainer.style.display = 'flex';
            startGame();
        });

        timeButtons.addEventListener('click', (e) => {
            if (e.target.tagName === 'BUTTON') {
                document.querySelectorAll('.time-buttons button').forEach(btn => btn.classList.remove('active'));
                e.target.classList.add('active');
                
                const timeStr = e.target.dataset.time;
                if (timeStr === '5m') totalTimeSeconds = 300;
                else if (timeStr === '10m') totalTimeSeconds = 600;
                else if (timeStr === '15m') totalTimeSeconds = 900;
                
                remainingTime = totalTimeSeconds;
                if (!gameStarted) {
                    timerDisplay.textContent = formatTime(remainingTime);
                }
            }
        });
        
        pauseBtn.addEventListener('click', () => {
            gamePaused = true;
            pauseBtn.style.display = 'none';
            resumeBtn.style.display = 'block';
        });

        resumeBtn.addEventListener('click', () => {
            gamePaused = false;
            pauseBtn.style.display = 'block';
            resumeBtn.style.display = 'none';
            lastTime = performance.now(); // 恢復時更新 lastTime
        });

        endBtn.addEventListener('click', () => {
            if (confirm('確定要結束本局遊戲嗎？')) {
                endGame(false);
            }
        });

        document.addEventListener('keydown', (e) => {
            if (!gameStarted || gamePaused) return;

            const key = e.key.toLowerCase();
            let newDir = null;

            if ((key === 'arrowup' || key === 'w') && direction !== 'down') newDir = 'up';
            else if ((key === 'arrowdown' || key === 's') && direction !== 'up') newDir = 'down';
            else if ((key === 'arrowleft' || key === 'a') && direction !== 'right') newDir = 'left';
            else if ((key === 'arrowright' || key === 'd') && direction !== 'left') newDir = 'right';

            if (newDir) {
                nextDirection = newDir;
                e.preventDefault(); 
            }
        });

        document.getElementById('controls').addEventListener('click', (e) => {
            if (!gameStarted || gamePaused) return;
            if (e.target.tagName !== 'BUTTON') return;
            
            const id = e.target.id;
            let newDir = null;
            
            if (id === 'up' && direction !== 'down') newDir = 'up';
            else if (id === 'down' && direction !== 'up') newDir = 'down';
            else if (id === 'left' && direction !== 'right') newDir = 'left';
            else if (id === 'right' && direction !== 'left') newDir = 'right';

            if (newDir) {
                nextDirection = newDir;
            }
        });

        window.onload = () => {
            loadLevelOptions(); 
            loadUnitOptions(); 

            const storedHigh = localStorage.getItem('snakeHigh');
            if (storedHigh) {
                highScore = parseInt(storedHigh, 10);
                highEl.textContent = highScore;
            }
            
            if (gameContainer.style.display !== 'none') {
                resizeCanvas();
            }
            
            timerDisplay.textContent = formatTime(totalTimeSeconds);
        };
    </script>
</body>
</html>
